
# Простой эмулятор 8 битного процессора и компилятор к нему

**0x64 cm)** - "Простой" эмулятор 8 битного процессора (не какого-то конкретного). Он имеет простенький сет инструкций, 2 кб ОЗУ, 4 8/16-битных регистра общего назначения, указатель стека, счетчик программы.

**ASMC** - "Простой" компилятор для 0x64 cm) использует синтаксис Intel, не чувствительный к регистру. На вход берет файл с интеловским ассемблером а на выходе выдает бинарник который можно запустить на эмуляторе.

*Во время разработки использовалась FingerLess архитектура (суть ее в том, что кривым разработчикам за кривой код в кривых приложениях отрубаются пальцы). Как видите, хорошего кода здесь нет, поскольку пальцев не осталось...*


* [Процессор](#Процессор)
  * [Регистры](#Регистры)
  * [Сет инструкций](#Сет-инструкций)
  * [Стек](#Стек)
  * [Системные вызовы](#Системные-вызовы)
  * [Параметры командной строки](#Параметры-командной-строки-эмулятора)
  * [Управление процессором](#Управление-процессором)
  * [Выполнение программы](#Выполнение-программы)
* [Компилятор](#Компилятор)
  * [Синтаксис](#Синтаксис)
  * [Бинарные файлы](#Бинарные-файлы)
  * [Параметры командной строки](#Параметры-командной-строки)
* [FAQ](#FAQ)
  * [В планах](#В-планах)


## Процессор

### Регистры

Все регистры(кроме статус-регистра) имеют следующую структуру:

|  Регистр AX (16 бит) |
| -- |
| *Старшие 8 бит* |
| *Регистр A (младшие 8 бит)* |

Размер регистра AX 16 бит, младшие 8 из которых занимает регистр A

| Регистр | Размер | Описание                 | Код |
|    --   |   --   |     --                   | --  |
|  AX/A   |  16/8  | Регистр общего назначения| 0xAA/0xA |
|  BX/B   |  16/8  | Регистр общего назначения| 0xBB/0xB |
|  CX/C   |  16/8  | Регистр общего назначения| 0xCC/0xC |
|  DX/D   |  16/8  | Регистр общего назначения| 0xDD/0xD |
|  PC     |  16    | Счетчик программы        | 0xE      |
|  SP     |  16    | Указатель стека          | 0xF      |
|  STATUS |  8     | Статус регистр с флагами | 0xAB     |

### Сет инструкций


![Сет инструкций](https://www.upload.ee/image/12338934/2020-10-01_195015.png)
---

| Сигнатура |  Значение    
|    --     |      --      |
|  **R**    | 8 битный регистр |
|  **R16**  | 16 битный регистр |
|  **d8**   | 8 битное число |
|  **d16**  | 16 битное число |
|  **a16**  | 16 битный адрес |
|    --     |      --      |
|  **w (word)**  | 16 битный тип данных |
|  **b (byte)**  | 8 битный тип данных |

---

### Стек

В этом процессоре как и в x86 стек растет вниз. Занимает адреса с **0x07EF** по **0x06EF**, в него можно записывать и читать (права **READ | WRITE**)

При вызове операции `PUSH` указатель стека (**SP**) **уменьшается** на нужный размер и значение записывается по указателю стека

А при вызове `POP` указатель стека (**SP**) **увеличивается** на нужный размер и значение читается по указателю стека

### Системные вызовы

Я стараюсь реализовать что то типо системных вызовов как в linux и unix но на уровне процессора 

Чтобы "вызвать систему" в регистр `**A**` нужно поместить номер сискола, а в остальные -- аргументы и вызвать систему командой `SYSCALL`

| **A** |       **B**        | Описание | 
|   --  |         --         |--|
|   0   |   Код завершения   | Выход из программы с кодом |
|   1   |   Код символа      | Добавить символ в буфер вывода|
|   2   |    -               | Очистить буфер вывода |
|   3   |    -               | Очистить дисплей |
|   4   |    -               | Вывести бувер вывода на дисплей |

### Параметры командной строки эмулятора

Для запуска вашей программы нужно в консоль ввести команду вида

`"путь\к\Simple 8-bit CPU emulator.exe" -i "путь\к\бинарнику.bin"`

|   Параметр  | Описание |
|      --     |     --      |
| --help, -h  | Получить помощь |
| --in, -i    | Входной файл |



### Управление процессором

|  Кнопка  | Описание |
|      --     |     --      |
| SPACE  | Сделать 1 шаг процессора |
| R  | Перезагрузить процессор |
| E  | Запустить/остановить выполнение программы |

---

![Пример](https://www.upload.ee/image/12338925/2020-10-01_195104.png)

---

### Выполнение программы

**Примерный алгоритм выполнения:**
* Инициализация
* Вечный цикл:
  * Ждать действий пользователя
  * Обработать действия пользователя
  * Шаг:
      * Прочитать из памяти код инструкции
      * Получить структуру ИНСТРУКЦИЯ по ее коду
      * Обработать 1 и 2 аргумент
      * Выполнить операцию
      * Увеличить счетчик программы



## Компилятор

### Синтаксис

По скольку мне не очень нравиться синтаксис 8 битных ассемблеров, я решил использовать чуть модифицированный синтаксис Intel

```
entry start


text: string "Hello world!"

start:
  call print
  hlt

print:
  mov ax, 1
  mov cx, text
  .loop:
    cmp [cx], 0
    je .finish
    mov byte b, [cx]
    syscall
    add cx, 1
    jmp .loop
  .finish:
  mov bx, 0xA ; \n
  syscall

  mov ax, 3 ; clear
  syscall

  mov ax, 4 ; print
  syscall
  ret

```

---
Паттерн инструкции выглядит так

`<имя инструкции> (<тип данных>) <аргумент 1>, <аргумент 2>`

Компилятор старается автоматически определить тип данных, но выходит это не всегда поэтому иногда нужно указывать их вручную (**byte (b)**, **word (w)**)

Например команда `mov b [0x0100], [0x0700]` перенесет **1** байт из памяти по адресу **0x0700** в память по адресу **0x0100**
а команда `mov w [0x0100], [0x0700]` перенесет уже **2** байта из памяти по адресу **0x0700** в память по адресу **0x0100**

---

### Бинарные файлы
После "компиляции" на выходе мы получаем голый бинарник с машинными кодами к эмулятору

Для того чтобы заглянуть в бинарник рекомендую использовать программку [HxD](https://mh-nexus.de/en/hxd/) или [hexdump](https://www.di-mgt.com.au/hexdump-for-windows.html)


---

### Параметры командной строки

Для компиляции нужно в консоль ввести команду вида

`путь\к\ASMC.exe -i "путь\к\исходнику.asm" -o "путь\к\бинарнику.bin"`

|   Параметр  | Описание |
|      --     |     --      |
| --help, -h  | Получить помощь |
| --in, -i    | Входной файл |
| --out, -o   | Выходной файл |
| --debug, -d | Показывать манипуляции компилятора с кодом (нужно для выявления ошибок) |

---

### Выполнение программы

**Примерный алгоритм работы:**
* Проверка и парсинг параметров командной строки
* Синтаксический анализ:
  * Прочитать файл
  * Пройтись построчно по нему
  * Распарсить строки на лексемы
* Лексический анализ и код генерация:
  * Подсчет размеров будущей программы
  * Поиск и замена именованных указателей в программе
  * Генерация кода
* Запись в файл.bin


## FAQ

* По поводу вопросов добро пожаловать в мой [Телеграм](https://t.me/Vxyxol)  или @Vxyxol

### В планах
1. Усложнить список инструкций 
2. Добавить постоянную память




#### **Вдохновлено** проектом Дэвида Бара (javidx9) [olcNES Emulator](https://github.com/OneLoneCoder/olcNES)


