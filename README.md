
# Простой эмулятор 8/16 битного процессора и компилятор к нему

**0x64 cm)** - "Простой" эмулятор 8/16 битного процессора (не какого-то конкретного). Он имеет простенький сет инструкций, 2 кб ОЗУ, 4 8/16-битных регистра общего назначения, указатель стека, счетчик программы.

**ASMC** - "Простой" компилятор для 0x64 cm) использует синтаксис Intel, не чувствительный к регистру. На вход берет файл с интеловским ассемблером а на выходе выдает бинарник который можно запустить на эмуляторе.

* [Процессор](#Процессор)
  * [Регистры](#Регистры)
  * [Сет инструкций](#Сет-инструкций)
  * [Стек](#Стек)
  * [Консольное меню](#Консольное-меню)
  * [Выполнение программы](#Выполнение-программы)
* [Компилятор](#Компилятор)
  * [Синтаксис](#Синтаксис)
  * [Бинарные файлы](#Бинарные-файлы)
  * [Параметры командной строки](#Параметры-командной-строки)
* [FAQ](#FAQ)
  * [В планах](#В-планах)


## Процессор

### Регистры

Все регистры(кроме статус-регистра) имеют следующую структуру:

|  Регистр AX (16 бит) |
| -- |
| *Старшие 8 бит* |
| *Регистр A (младшие 8 бит)* |

Размер регистра AX 16 бит, младшие 8 из которых занимает регистр A

| Регистр | Размер | Описание                 | Код |
|    --   |   --   |     --                   | --  |
|  AX/A   |  16/8  | Регистр общего назначения| 0xAA/0xA |
|  BX/B   |  16/8  | Регистр общего назначения| 0xBB/0xB |
|  CX/C   |  16/8  | Регистр общего назначения| 0xCC/0xC |
|  DX/D   |  16/8  | Регистр общего назначения| 0xDD/0xD |
|  PC     |  16    | Счетчик программы        | 0xE      |
|  SP     |  16    | Указатель стека          | 0xF      |
|  STATUS |  8     | Статус регистр с флагами | 0xAB     |

### Сет инструкций

![Сет инструкций](https://www.upload.ee/image/11533030/2020-04-21_204238.png)

---

| Сигнатура |  Значение    
|    --     |      --      |
|  **R**    | 8 битный регистр |
|  **R16**  | 16 битный регистр |
|  **d8**   | 8 битное число |
|  **d16**  | 16 битное число |
|  **a16**  | 16 битный адрес |
|    --     |      --      |
|  **w (word)**  | 16 битный тип данных |
|  **b (byte)**  | 8 битный тип данных |

---

### Стек

В этом процессоре как и в x86 стек растет вниз. Занимает адреса с **0x07EF** по **0x06EF**, в него можно записывать и читать (права **READ | WRITE**)

При вызове операции `PUSH` указатель стека (**SP**) **уменшаеться** на нужный размер и значение записывается по указателю стека

А при вызове `POP` указатель стека (**SP**) **увеличивается** на нужный размер и значение читается по указателю стека


### Консольное меню

Для удобства работы с эмулятором и его дебагинга было добавлено консольное меню

| Команда |  Описание    |
|          --             |      --      |
| **.registers, .regs**   | При вводе этой команды в консоль выведется содержимое регистров и флагов|
| **.memory, .mem**       | При вводе этой команды в консоль выведется содержимое ВСЕХ 2 кб ОЗУ|
| **.execute, .exec**     | При вводе этой команды процессор начнет работать в режиме выполнения до команды HALT (не будет спрашивать команду)|
| **.reset**              | При вводе этой команды произойдет перезапуск|
| **.disassemble, .dasm** | При вводе этой команды в консоль выведется дизассемблированые первие 21 байт памяти|
| **.exit**               | При вводе этой команды будет произведен выход из программы|
| **Enter**               | Будет сделан 1 шаг процессора|

---

### Выполнение программы

**Примерный алгоритм выполнения:**
* Инициализация
* Вечный цикл:
  * Ждать действий пользователя
  * Обработать действия пользователя
  * Шаг:
      * Прочитать из памяти код инструкции
      * Получить структуру ИНСТРУКЦИЯ по ее коду
      * Обработать 1 и 2 аргумент
      * Выполнить операцию
      * Увеличить счетчик программы



## Компилятор

### Синтаксис

По скольку мне не очень нравиться синтаксис 8 битных ассемблеров, я решил использовать чуть модифицированный синтаксис Intel

```
jmp start ; 0xC9, 0x00, 0x03

start:
  mov bx, 10 ; 0x40, 0xBB, 0x00, 0x0A
  mov cx, 10 ; 0x40, 0xCC, 0x00, 0x0A
  call multiply ; 0x89, 0x00, 0x0F
  hlt ; 0xAF

; Простая фуннкция умножения двох чисел
; bx, cx - in
; ax - out
multiply:
  push dx ; 0x59, 0xDD
  mov dx, 0 ; 0x40, 0xDD, 0x00, 0x00
  mov ax, 0 ; 0x40, 0xAA, 0x00, 0x00
  .loop:
    cmp dx, cx ; 0xD0, 0xDD, 0xCC
    je .finish ; 0xCA, 0x00, 0x29
    add ax, bx ; 0x53, 0xAA, 0xBB
    add dx, 1 ; 0x43, 0xDD, 0x00, 0x01
    jmp .loop ; 0xC9, 0x00, 0x19
  .finish:
  pop dx ; 0x5A, 0xDD
  mov status, 0 ; 0x00, 0xAB, 0x00
  ret ; 0x9F
```

---
Паттерн инструкции выглядит так

`<имя инструкции> (<тип данных>) <аргумент 1>, <аргумент 2>`

Компилятор старается автоматически определить тип данных, но выходит это не всегда поэтому иногда нужно указывать их вручную (**byte (b)**, **word (w)**)

Например команда `mov b [0x0100], [0x0700]` перенесет **1** байт из памяти по адресу **0x0700** в память по адресу **0x0100**
а команда `mov w [0x0100], [0x0700]` перенесет уже **2** байта из памяти по адресу **0x0700** в память по адресу **0x0100**

---

### Бинарные файлы
После "компиляции" на выходе мы получаем голый бинарник с машинными кодами к эмулятору

Для того чтобы заглянуть в бинарник рекомендую использовать программку [HxD](https://mh-nexus.de/en/hxd/) или [hexdump](https://www.di-mgt.com.au/hexdump-for-windows.html)

Пока что не получиться запустить бинарник на эмуляторе (Он пока что не умеет их читать)

  Если очень хочется можно в файле main.cpp (проекта **Simple 8-bit cpu emulator**) указать прямой путь к скомпилированой программе

---

### Параметры командной строки

Для компиляции нужно в консоль ввести команду вида

`путь\к\ASMC.exe -i "путь\к\исходнику.asm" -o "путь\к\бинарнику.bin"`

|   Параметр  | Описание |
|      --     |     --      |
| --help, -h  | Получить помощь |
| --in, -i    | Входной файл |
| --out, -o   | Выходной файл |
| --debug, -d | Показывать манипуляции компилятора с кодом (нужно для выявления ошибок) |

---

### Выполнение программы

**Примерный алгоритм работы:**
* Проверка и парсинг параметров командной строки
* Синтаксический анализ:
  * Прочитать файл
  * Пройтись построчно по нему
  * Распарсить строки на лексемы
* Лексический анализ и код генерация:
  * Подсчет размеров будущей программы
  * Поиск и замена именованных указателей в программе
  * Генерация кода
* Запись в файл.bin


## FAQ

* По поводу вопросов добро пожаловать в мой [Телеграм](https://t.me/Vxyxol)  или @Vxyxol

### В планах
1. Усложнить список инструкций 
2. Добавить постоянную память
3. Добавить графику



#### **Вдохновлено** проектом Дэвида Бара (javidx9) [olcNES Emulator](https://github.com/OneLoneCoder/olcNES)


